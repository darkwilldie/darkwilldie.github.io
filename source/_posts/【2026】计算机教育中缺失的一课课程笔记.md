---
title: 【2026】计算机教育中缺失的一课课程笔记
date: 2026-02-26 14:02:51
tags:
categories:
---
<!-- toc -->

# 打包和发行代码

## 安装依赖和虚拟环境

### 标准工具：pip

```sh
# 安装和查看
pip install requests
pip list
# 查看包路径
python -c 'import requests print(requests.__file__)'

# 虚拟环境与激活
python -m venv myvenv
source myvenv/bin/activate
which python # 查看当前使用的Python路径
```

### 高性能替代方案：uv

`uv`可以完全替代`pip`，由 Rust 编写，比`pip`快几个数量级，能同时管理虚拟环境和python版本。

linux可以通过`curl -LsSf https://astral.sh/uv/install.sh | sh`安装。

| **步骤**     | **使用 venv (标准)**        | **使用 uv (推荐)**          |
| ------------ | --------------------------- | --------------------------- |
| **创建环境** | `python -m venv .venv`      | `uv venv`                   |
| **指定版本** | 取决于当前系统 Python       | `uv venv --python 3.12`     |
| **激活环境** | `source .venv/bin/activate` | `source .venv/bin/activate` |
| **安装包**   | `pip install requests`      | `uv pip install requests`   |

### 📦 项目构建

#### 1. 核心配置：`pyproject.toml`

现代 Python 打包标准。定义项目名、版本、依赖及命令行入口。

- **入口配置示例**：`greet = "greeting:cli"` (安装后输入 `greet` 即可运行)。

#### 2. 本地开发与安装

- **本地安装**：将当前源码安装到环境，支持全局调用。

  ```sh
  uv pip install .
  ```

- **验证路径**：确认包已安装至虚拟环境的 `site-packages`。

  ```sh
  pip show greeting
  ```

#### 3. 构建分发构件 (Artifacts)

- **执行构建**：生成可分发的文件。

  ```sh
  uv build
  ```

- **产出物说明**：

  - **Wheel (.whl)**：预编译归档，本质是 **ZIP 格式**，安装速度最快。
  - **sdist (.tar.gz)**：源码包。

#### 4. 依赖分析

- **查看依赖树**：分析项目及其所有深层依赖。

  ```sh
  uv tree
  ```

#### 5. 关键总结

- **源码**：原始代码，需环境配置。
- **构件 (Wheel)**：打包后的最终产品，跨环境分发的标准格式。

根据视频 [Lecture 6: Packaging and Shipping Code](http://www.youtube.com/watch?v=KBMiB-8P4Ns) 的内容，以下是关于 **Docker** 及其后续内容的 Markdown 笔记总结。

------

# Docker 与容器化技术

## 1. 容器 (Containers) 基础概念

- **背景**：为了解决“在我的机器上能运行，但在别人机器上不行”的问题。
- **容器 vs 虚拟机 (VM)**：
  - **虚拟机**：在宿主机上模拟完整的硬件和操作系统，开销大、启动慢。
  - **容器**：共享宿主机的操作系统内核，只在用户层进行隔离。它比虚拟机更轻量、运行更快。
- **Docker**：目前最流行的容器化平台。

## 2. Docker 基础操作命令

- **交互式运行镜像**：

  `docker run -it python`

  - `-it`：开启交互式终端，让你能进入容器内部操作。

- **查看本地镜像列表**：

  `docker images`

- **进入容器查看系统环境**：

  `docker run -it python bash`

  - 可以发现容器内部通常是一个精简版的 Linux（如 Debian）。

## 3. 构建自己的镜像：Dockerfile

Dockerfile 是一个文本文件，包含了构建镜像的所有指令。

### 基础 Dockerfile 示例：

``` Dockerfile
FROM python:3.14          # 指定基础镜像
RUN apt-get update && apt-get install -y gcc  # 安装系统依赖
COPY . /app               # 将当前目录代码复制到镜像的 /app 目录
WORKDIR /app              # 设置工作目录
RUN pip install .         # 安装 Python 包
CMD ["greet"]             # 容器启动时默认执行的命令
```

### 镜像构建命令：

```sh
docker build -t my-greet-app .
```

- `-t`：给镜像起一个标签（名字）。
- `.`：指在当前目录下寻找 Dockerfile。

## 4. Dockerfile 优化

- **减少层数**：每一个 `RUN` 指令都会增加镜像体积。建议使用 `&&` 合并命令。
- **清理缓存**：在安装完软件后删除安装包和缓存。
- **体积对比**：未优化的镜像可能接近 2GB，而经过优化的镜像（清理缓存、合并指令后）可以缩小到 500MB 甚至更小。

## 5. 多服务协作：Docker Compose

当应用需要数据库或其他服务配合时，使用 Docker Compose 来统一管理多个容器。

### 配置文件 `docker-compose.yml` 示例：

YAML

```
services:
  db:
    image: redis:latest   # 数据库服务
  web:
    build: .              # 使用当前目录构建 Web 服务
    depends_on:
      - db                # 确保数据库先启动
    environment:
      - DB_URL=redis://db # 通过环境变量传递配置
```

### 常用命令：

- **启动所有服务**：`docker compose up`
- **后台启动**：`docker compose up -d`
- **停止并清理服务**：`docker compose down`

## 6. 生产环境部署与自动启动

- **Systemd 集成**：在 Linux 服务器上，可以编写 Systemd 服务文件来管理 Docker。
- **自动重启**：通过设置 Systemd，确保服务器重启后，Docker 容器能自动拉起。
- **管理命令**：
  - 启动服务：`sudo systemctl start my-app`
  - 查看状态：`sudo systemctl status my-app`

## 7. 发布与分发 (Shipping)

- **Docker Hub**：类似于代码的 GitHub，是存储和分享镜像的仓库。
- **发布流程**：
  1. **登录**：`docker login`
  2. **打标签**：`docker tag my-app username/my-app:v1`
  3. **推送**：`docker push username/my-app:v1`
- **协作**：一旦镜像推送到仓库，其他任何人（有权限的话）只需执行 `docker pull` 即可获得完全一致的运行环境，无需手动安装任何依赖。

